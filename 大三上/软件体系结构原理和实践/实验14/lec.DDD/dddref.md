# Domain Driven Design Reference（一）—— 前言



> 本书是Eric Evans对他自己写的《领域驱动设计-软件核心复杂性应对之道》的一本字典式的参考书，可用于快速查找《领域驱动设计》中的诸多概念及其简明解释。

 

## 致谢

　　自从《Domain-­‐Driven  Design, Tackling  Complexity  in  the  Heart  of  Software》（或者叫“大蓝书”，正如有些人所说的那样） 出版以来已经有10年多的时间了。在这段期间内，书中讨论的基本原理没有太多变化，但是关于我们如何构建软件发生了很大的变化。DDD仍然保持着关联是因为聪明和创新的人们在不断的改变着它。我想要感谢那些人。

　　让我从Greg Young, Udi Dahan和在CQRS、Event Sourcing上受他们启发的人开始讲。这些是现在DDD系统的主流架构选项。这是本世纪初有限视角的架构中衍生的第一个成功的大发展。

　　从那以后，有许多以DDD更加落地为目标（以及他们的设计者的其它目标）的有趣技术和框架出现，取得了不同程度的成功。包括Qi4J，Naked Objects，Roo等等。这样的尝试即使没有得到广泛的采用，也具有很大的价值。

　　我还是想要感谢那些变革我们的技术生态的人和社区，使得DDD更加的有趣和实用。这些人中大多数对DDD的兴趣很小，但他们的工作使我们受益匪浅。我特别想到NoSQL给我们带来的自由，减少了新编程语言（一些功能）的语法噪声，以及对更轻的技术框架和非侵入性，解耦的类库的不懈努力。10年前的技术复杂而笨重，使得运用DDD十分困难。当然也有不好的新技术，但趋势是好的。 因此，我特别感谢所有为这一趋势做出贡献的人，尽管您可能从未听说过DDD。

　　接下来，我要感谢那些写了关于DDD的书籍的人。在我之后关于DDD的第一本书来自 Jimmy Nilsson【**1，额外补充一下是这本《领域驱动设计与模式实战 [Applying domain-driven design and patterns]》**】。有一本书的话，你仅仅“有一本书”而已。但是有2本的话，你就有了一个主题。接下来，InfoQ发布了《DDD Quickly》，由于其简洁，免费下载以及InfoQ的影响力，让很多人第一时间了解了该主题。这些年过去了，还有许多有价值的博客文章和其它的短文。也有专门的书籍，如《DDD with Naked Objects》【**2，额外补充一下找不到文中同名的书，猜测可能是这本《Domain-Driven Design Using Naked Objects》**】。另外我特别想要感谢不可缺少的Martin Fowler，他除了经常提供新兴模式的权威文档还帮助清楚的传达DDD的概念。就在去年，Vaughn Vernon发表了自我以来最有雄心的书，《Implementing Domain-­‐Driven  Design》（有些人似乎称之为“大红书”）。

　　我感到一种绝望，就是我会抛弃许多做出重大贡献的人，我真的为此感到遗憾。让我至少给那些把DDD推到公众视野的人和那些把DDD推到组织安静的角落的人表示谢意。一个软件哲学需要成千上万的拥护者才能产生影响力。

　　虽然这是《DDD Reference》的首印版，单却是我2004年出版的书籍的最初的样子。根据Ralph Johnson的一个建议，我提取了每个模式的简要总结并在研讨会使用它们，每个模式都由与会者大声朗读，随后进行讨论。我把这些文件用于培训班好几年了。

　　然后，在我的书出版几年之后，Ward Cunningham，将他在Repository模式中工作的一部分向几位作者提出，然后我们把我们模式的简短摘要加入到 Creative Commons【**3，一个知识共享组织，参见https://baike.baidu.com/item/creative%20commons/8755425?fr=aladdin**】中了。Martin Fowler和我在出版商Pearson Education公司的协议下做到了这一点，这就为这种衍生作品开创了可能性。

## 定义

　　领域（domain）：知识、影响或者作用的一个范围。用户应用一个程序的主题范围是软件的领域。

　　模型（model）：一个抽象的系统，用来描述一个领域的指定的方面，并且可用于解决与该领域有关的问题。

　　通用语言（ubiquitous language ）：围绕领域模型构建的一种语言，所有团队成员都可以在限定的上下文中使用该软件将团队的所有活动连接起来。

　　上下文（context）：决定一个单词或者句子出现所表示含义的环境。有关模型的生命只能在上下文中被理解。

　　限界上下文（bounded context）：描述一个特定模型被定义和适用的边界（通常是一个子系统，或一个特定团队的工作）。

## 模式预览概览

　　![img](terms.png)


# [译文]Domain Driven Design Reference（二）—— 让模型起作用


## 让模型起作用

　　领域驱动设计是一种开发复杂软件的方法：

　　　　1.专注核心领域。

　　　　2.探索领域从业者和软件从业者的创造性协作模式。

　　　　3.在一个明确的限界上下文内讲通用语言。

　　DDD的三点总结依赖于本手册定义的术语来定义。

　　很多项目做建模工作最终没有获得太多的实际好处。DDD模式从项目中提炼成功的实践使得建模带来了巨大的好处。总的来说，他们提出了一个与先从细节再到高层次的视角【**1，在DDD之前我们大部分都习惯于先进行数据表的设计**】完全不同的建模和软件开发的方式。严格的建模惯例必须平衡好与非技术人员【**2，一般这里指领域专家**】合作进行的模型探索。战术和战略必须结合才能成功，DDD同时涉及战术和战略的设计。

## 限界上下文

　　任何大型项目都有多个模型。它们出现的原因很多。两个子系统通常服务于非常不同的用户群体，具有不同的工作，其中建立不同的模型可能是有作用的。团队独立工作由于缺乏沟通可能以不同的方式解决了同样的问题。工具集也可能不同，这意味着程序代码不能共享。

　　多个模型是不可避免的，而当基于不同模型的代码被合并时，软件变得充满BUG，不可靠，而且难以理解。团队成员之间的交流变得困惑。在什么情况下不应该使用模型通常是不清楚的。

　　模型表达式与其他任何短语一样，仅在上下文中具有含义。

　　因此：

　　明确定义模型适用的上下文。根据团队组织，应用程序特定部分的使用情况以及例如代码库和数据库模式等物理表现明确设置边界。应用“持续集成”可使模型概念和术语在这些范围内保持严格一致，但不要被外部问题分散或混淆。在上下文中标准化一个单独的开发过程，这个开发过程不需要在其他地方使用。

## 通用语言

　　首先写下一个句子，

　　然后将它分成小段，

　　再将它们打乱并重新排序。

　　仿佛是巧合一样，

　　短语的顺序对意思完全没有影响。

　　*–Lewis Carroll, “Poeta Fit, Non Nascitur”*

　　要想创建一种灵活的、蕴含丰富知识的设计，需要一种通用的、共享的团队语言，这种语言应该是时刻进行检验的，遗憾的是，在软件项目上很少出现这样的检验。

　　在一个单一的限界上下文内，语言可能会以某种方式被破坏，削弱了在应用复杂建模上的努力。如果该模型仅用于为团队的技术人员绘制UML图，那么这对DDD核心的创造性合作没有任何贡献。

　　领域专家使用他们的术语，而技术团队成员有自己的语言来从设计的角度讨论这个领域。日常讨论的术语与代码中嵌入的术语（最终是软件项目最重要的产品）。甚至同一个人在说和写中都会使用不同的语言，使得这个领域中最尖锐的表达常常以暂时的形式出现，而这种形式永远不会在代码中甚至在书面中被捕捉到。

　　翻译会导致沟通不畅，使得知识匮乏。

　　然而，这些语言都不能成为一种共同的语言，因为没有一种服务于所有需求。

　　领域专家应该反对别扭或不足以传达领域理解的术语或结构；开发人员应该注意有无歧义或不一致将妨碍设计。

　　在谈论这个系统的时候，带上模型。使用模型的元素和交互来大声描述场景，以模型允许的方式结合概念。找到更简单的方法来说出你需要说的话，然后把这些新的想法带回图表和代码中。随着语言的普及，模型不仅仅是一个设计品。它成了开发人员和领域专家一起要完成的不可或缺的事情。

　　因此：

　　使用模型作为语言的支柱。保证团队在团队和代码中的所有交流中不懈地运用这种语言。在一个限界上下文中，在图表，写作，尤其是交流中使用相同的语言。

　　意识到言语的改变就是对模型的改变。

　　通过实验替代表达式来体现替代模型来解决困难。然后重构代码，重命名类，方法和模块以符合新模型。解决对话中的术语混淆，就像我们对普通单词的意义认知是一致的一样。

## 持续集成

　　一旦定义了限界上下文，我们就必须保持它的健康。

　　当许多人在一个相同的限界上下文里工作时，模型碎片化会是一个强烈的趋势。团队越大，问题就越大，但只有三四个人就会遇到严重的问题。然而，将系统分解成更小的上下文最终会失去一个整合和内聚的价值。

　　因此：

　　经常研究一个合并所有代码和其它实现工件的过程，通过自动化测试来快速标记碎片。不懈的运用通用语言，随着概念在不同人的头脑中的演变，逐渐形成对模型的共同观点。

## 领域驱动设计

　　将代码与底层模型紧密联系在一起给出了代码的含义，并使模型具有相关性。

　　如果设计或其中心部分没有映射到领域模型，那么该模型没有什么价值，并且软件的正确性是可疑的。同时，模型和设计功能之间的复杂映射是难以理解的，并且实际上不可能保持的像设计的改变一样。在分析和设计之间设立一道红线，使得在每一个这样的活动中获得的洞察力都不会影响到另一个。

　　从模型中提取在设计中使用的术语和职责的基本分配。代码成为模型的表达式，所以对代码的改变就是对模型的改变。从而它的影响必然涉及到该项目的其余活动。

　　因此：

　　设计软件系统的一部分，以非常直观的方式反映领域模型，以便映射是显而易见的。重新审视模型并修改它，以便在软件中更自然地实现，即使您试图使其更深入地反映领域。需要一个单一的模型，来除了支持一个顺畅的通用语言之外，同时满足目的正确。

## 动手建模者

　　如果编写代码的人不对模型负责，或者不知道如何使模型适用于应用程序，那么模型与软件无关。如果开发人员没有意识到改变代码会改变模型，那么他们的重构就会削弱模型而不是加强模型。与此同时，当建模者与实现过程分离时，从未获得或很快失去对实现约束的感觉。领域驱动设计的基本约束是模型支持有效的实现并且抽象出对领域的关键洞察，已经过去了一半，所产生的模型将是不切实际的。最后，如果分工阻止了这种协作，经验丰富的设计师的知识和技能不会转移到其他开发人员，这是传达了领域驱动设计编码的微妙之处。

　　因此：

　　任何对模型有贡献的技术人员都必须花费一些时间来接触代码，无论他在项目中扮演什么主要角色。任何负责更改代码的人都必须学会通过代码来表达模型。每个开发者都必须参与一些关于模型的讨论，并与领域专家联系。那些以不同方式作出贡献的人，必须有意的聘请那些在一个通过通用语言动态交换模型想法中接触代码的人。

## 重构深入的洞察力

　　使用一套经过验证的基本构建模块以及一致的语言为开发工作带来了一些清晰的思路。这避免了真正找到一个尖锐模型的挑战，一个捕获领域专家的微妙担忧和可以推动一个切实的设计。一个在肤浅的表面下的模型抓住的本质是一个深层的模型。这应该使软件更符合领域专家的思维方式，并且更加符合用户的需求。

　　传统意义上，重构是被用于描述由技术动机进行代码转换的词。重构也可以通过对领域的洞察以及对代码中模型或其表达的相应改进来激发。

　　复杂的领域模型很少发挥作用，除非通过重构的迭代过程来开发，包括领域专家与有兴趣了解该领域的开发者的密切参与。



# [译文]Domain Driven Design Reference（三）—— 领域驱动设计的构建模块

> 本书是Eric Evans对他自己写的《领域驱动设计-软件核心复杂性应对之道》的一本字典式的参考书，可用于快速查找《领域驱动设计》中的诸多概念及其简明解释。

## 领域驱动设计的构建模块

　　这些模式根据领域驱动设计，广泛地推行了面向对象设计的最佳实践。他们指导决策来提炼模型，并使模型和实现保持一致，每一个都增强了其他的有效性。仔细制定模型元素的细节为开发人员提供了一个稳定的平台，从中可以探索模型并使其与实现保持紧密联系。



## 分层架构

　　在面向对象的程序中，用户界面，数据库和其他支持代码通常会直接写入业务对象。额外的业务逻辑被嵌入在UI部件和数据库脚本的行为中。发生这种情况是因为在短期内，这样做是最简单的方法。

　　当与领域相关的代码通过如此大量的其他代码被扩散时，变得非常难以理解和推理。UI的表面变化实际上可以改变业务逻辑。要更改业务规则，可能需要仔细跟踪UI代码，数据库代码或其他程序元素。实现一致的、领域驱动的对象变得不切实际。自动化测试变得难以进行。由于每个活动都涉及到所有的技术和逻辑，程序必须保持非常简单，否则就无法理解。

　　因此：

　　**隔离领域模型和业务逻辑的表达形式，并消除对基础架构，用户界面甚至非业务逻辑的应用程序逻辑的依赖。将一个复杂的程序分成多个层。**

- **在每个层次内开发一个内聚的设计，并且仅依赖于下面的层。⭐遵循标准的建筑模式，为上面的分层提供松散的耦合。将所有与领域模型相关的代码集中在一个层中，并将其与用户界面，应用程序和基础设施的代码隔离。**
- **领域对象没有显示自己，存储自己，管理应用程序任务等等的职责⭐，可以集中在表达领域模型上。这使得一个模型能够发展到足够丰富，足够清晰，能够捕获必要的业务知识并将其付诸实践。**

　　这里的关键目标是隔离。 诸如“六边形架构”之类的相关模式可以起到允许我们的领域模型表现避免依赖和引用其他系统问题，甚至更好的效果。



## 实体⭐

　　许多对象代表了一个连续的具有身份标识的主线，贯穿整个生命周期，尽管其属性可能会改变。一些对象不是主要由它们的属性定义的。它们代表了贯穿时间并经常跨越不同展现形式的主线的身份标识。有时这样的对象必须与另一个对象匹配，即使属性不同。错误的身份可能导致数据损坏。

　　因此：

　　⭐**当一个对象被它的身份而不是它的属性所区分时，把它作为它在模型中定义的要点。保持简单的类定义，并关注生命周期的连续性和身份标识。**

　　**定义一个区分每个对象的方法，而不管它的形式或历史。 对通过属性调用匹配对象的需求保持警惕。定义一个保证为每个对象产生唯一结果的操作，可能通过附加一个保证唯一的符号。这种标识手段可能来自外部，也可能是由系统创建的任意标识符，但必须符合模型中的身份标识区别。**

　　**模型必须定义什么是同样的事情。**

　　（又称参考对象）



## 值对象⭐

　　有些对象描述或计算事物的一些特征。

　　许多对象没有概念上的身份标识。

　　跟踪实体的身份标识至关重要。但将身份标识附加到其他对象可能会伤害系统性能，增加分析工作，并使所有对象看起来都一模一样。软件设计是一个复杂的持续战斗。我们必须作出区分，以便只有在必要时才进行特殊处理。

　　然而，如果我们把这种类型的对象看作是缺少身份的话，那么我们并没有在我们的工具箱或词汇中添加太多东西。实际上，这些对象具有自己的特点，对模型本身也有意义。 这些是描述事物的对象。

　　因此：

　　⭐**当您只关心模型元素的属性和逻辑时，将其归类为值对象。使其表达它传达的属性的含义并赋予它相关的功能。将值对象视为不可变的。使所有操作是不依赖任何可变状态的无副作用函数。不要给值对象任何身份标识，并避免保留实体所必需的设计复杂性。**



## 领域事件

　　领域专家关心的事情发生了。一个实体负责跟踪其状态和规定其生命周期的规则。但是，如果你需要知道状态变化的实际原因，这通常是不明确的，并且可能很难解释系统如何实现它。审计线索可以允许跟踪，但通常不适合用于程序本身的逻辑。实体的变化历史可以允许访问先前的状态，但忽略这些变化的含义，以便对信息的任何操作都是程序性的，并且经常被抛出领域层。

　　分布式系统中出现了一系列独特但又相关的问题。分布式系统的状态在任何时候都不能保持完全一致。我们始终保持聚合内部一致，而异步的进行其他更改。当更改在网络的节点间传播时，可能很难解决无序或来自不同来源的多个更新。

　　因此：

　　**将关于领域中活动的模型信息视为一系列离散事件。将每个事件表示为一个领域对象。这些不同于系统事件，它们反映了软件本身的活动，虽然通常系统事件与领域事件相关联或者作为领域事件的响应的一部分，或者作为将领域事件的信息携带到系统中的一种方式。**

　　**领域事件是领域模型的一个完整的部分，是领域中发生的事情的表示形式。忽略不相关的领域活动，同时明确领域专家想要跟踪或者被通知的事件，或者与其他模型对象中的状态改变相关联的事件。**

　　在分布式系统中，实体的状态可以从特定节点的当前已知的领域事件中推断出来，从而在没有关于整个系统的完整信息的情况下得到相关的模型。

　　领域事件通常是不可变的，因为它们是过去的某种事物的记录。除了对事件的描述之外，领域事件通常包含事件发生时间的时间戳以及事件涉及的实体的身份标识。此外，领域事件通常具有单独的时间戳，指示事件何时进入系统以及使其进入系统的人的身份标识。如果有用，领域事件的身份标识可以基于这些属性的一些集合。所以，例如，如果同一个事件的两个实例到达一个节点，则它们可以被识别为相同的。



## 服务

　　有时候，这不是一回事。领域的一些概念由模型作为对象是不自然的。强制所需的领域功能成为实体或者值对象的职责，要么篡改基于模型的对象的定义，要么添加无意义的虚拟对象。

　　因此：

　　**当领域中的重要流程或转换不是实体或值对象的自然职责时，添加一个操作到模型中作为一个单独的接口同时声明为一个服务。定义一个服务契约，一组关于与服务交互的声明。用一个特定限界上下文的通用语言来陈述这些声明。给服务一个名字，这也成为通用语言的一部分。**



## 模块

　　每个人都使用模块，但很少将它们视为模型的完整部分。代码被分解成各种类别，从技术架构的各个方面到开发人员的工作任务。即使是做了很多重构的开发人员也倾向于使用项目早期构思的模块。

　　耦合和凝聚力的解释倾向于使它们听起来像是技术指标，根据关联和相互作用的分布进行机械的判断。然而，这不仅仅是将代码划分为模块，还包括概念。一个人一次可以思考多少事情是有限的（因此耦合度低），不连贯的想法片段很难被理解为一个无差别的想法（因此具有很高的内聚性）。

　　因此：

　　**选择能够讲述系统故事的模块，并包含一系列内聚的概念。让模块名称成为通用语言的一部分。模块是模型的一部分，它们的名称应反映对领域的洞察。**

　　**这通常会导致模块之间的低耦合，但是如果它不寻找一种方法来改变模型来分解概念，或者是一个被忽视的概念，它可能是一个能够以有意义的方式将元素组合在一起的模块的基础。在可以被独立地理解和推理的概念上寻求低耦合。根据高层领域概念对模型进行细化直到它被划分，****并将相应的代码解耦。**



## 聚合

　　要保证复杂关联模型中对象变化的一致性是很困难的。他们能够被是概念上的构成部分的其它对象的变化所掩盖。在多个服务器之间分发对象或设计异步事务时会出现类似的问题。

　　因此：

　　**将实体和值对象集中到聚合中并在周围定义边界。⭐选择一个实体作为每个聚合的根，并允许外部对象仅保留对根的引用（对内部成员的引用仅在一个操作中返回出去才能使用）。定义聚合的属性和不变量作为一个整体，并将这个约束的责任赋予根【这里指的是聚合根】或某种指定的框架机制。**

　　使用相同的聚合边界来管理事务和分配。

　　在一个聚合边界内，同步地应用一致性规则。 跨越边界，异步地处理更新。

　　在一台服务器上共同维护一个聚合。允许不同的聚合在节点间分配。

　　如果这些设计决策没有受到聚合边界的良好指导，请重新考虑模型。是领域的场景正在暗示着一个重要的新见解吗？这种改变通常会提高模型的表现力和灵活性，并解决事务和分配问题。



## 仓储

　　查询通用语言表达的聚合。

　　可遍历的关联的扩散只用于找到弄乱模型的东西。在成熟模型中，查询经常表达领域概念。然而查询可能会导致问题。

　　应用大多数数据库访问基础架构的纯粹技术复杂性迅速吞噬了客户端代码，导致开发人员陷入了领域层，使得模型无关紧要。

　　查询框架可能会封装大部分的技术复杂性，使开发人员能够以更自动化或声明的方式从数据库中提取所需的确切数据，但这只能解决一部分问题。

　　不受约束的查询可能会从对象中拉出特定的字段，违反封装，或从聚合内部实例化几个特定的对象，让聚合根变得充满变数并使这些对象无法执行领域模型的规则。领域逻辑移入查询和应用程序层代码，实体和值对象变成仅仅为数据容器。

　　因此：

　　**对于需要全局访问的每种聚合类型，创建一个服务，它可以提供所有聚合根类型的对象的在一个内存集合中的错觉。通过一个大家都知道的全局接口设置访问。提供添加和删除对象的方法，这将封装实际数据往数据存储中的插入或删除。提供基于对领域专家有意义的标准来选择对象的方法。返回完全实例化的对象或属性值符合条件的对象集合，从而封装实际的存储和查询技术，或者返回给予以惰性的方式完全实例化的聚合的幻觉的代理。仅为实际需要直接访问的聚合根提供仓储。保持应用程序逻辑专注于模型，委托所有的对象存储和访问给仓储。**



## 工厂

　　当创建一个完整的，内部一致的聚合或者一个大值对象变得复杂或者显示太多的内部结构时，工厂提供封装。一个对象的创建本身可以是一个主要的操作，但是复杂的组装操作不适合由创建的对象来承担。将这些职责结合起来可能会产生难以理解并且难看的设计。让客户端直接组装会混乱客户端的设计，破坏组装对象或集合的封装，并且过度地将客户端耦合到所创建对象的实现中【举个例子，这里的客户端可以理解成应用层或者UI层】。

　　因此：

　　**将创建复杂对象和聚合实例的责任转移到单独的对象上，这个对象本身可能在域模型中没有职责，但仍然是领域设计的一部分。提供一个封装所有复杂程序集的接口，并且不要求客户端引用实例化对象的具体类。将创建一个完整的聚合作为一部分，强制实施它的不变性。****创建一个复杂的值对象，可能是在将元素与构建器组合后。**







# [译文]Domain Driven Design Reference（四）—— 柔性设计

> 本书是Eric Evans对他自己写的《领域驱动设计-软件核心复杂性应对之道》的一本字典式的参考书，可用于快速查找《领域驱动设计》中的诸多概念及其简明解释。

# Ⅲ.柔性设计

　　要让一个项目加速发展，而不是被其自身的历史包袱所拖累，需要一个能与之良好协作的设计，它会带来改变。一个柔性设计。

　　柔性设计是对深度建模的补充。

　　开发人员扮演两种角色，每种角色都必须通过设计来完成。同一个人可能扮演这两个角色，甚至可以在几分钟内来回切换，但与代码的关系却不是这样。一个角色是客户端的开发人员，他们利用设计的方式将领域对象编织到应用程序代码或其他域层代码中。柔性设计揭示了一个深层次的潜在模型，使其潜在性变得清晰。客户端开发人员可以灵活地使用一组最小松散耦合的概念来表示域中的一系列场景。设计元素以自然的方式融合在一起，其结果是可预测的，清晰的特征并且是健壮的。

　　同样重要的是，设计必须服从于开发人员来改变它。要做出改变，设计必须易于理解，并能表达出客户端开发人员正在使用的相同底层模型。它必须遵循该领域深层模型的概念，所以大多数变化都会在灵活点上柔性设计。其代码的影响必须透明明显，因此更改的后果将很容易预测。

　　　　•  使行为特征明显

　　　　•  降低变更成本

　　　　•  创建与之合作的软件开发人员

## 释意接口

　　如果开发人员必须考虑组件的实现才能使用它，则封装的价值就没有了。如果原始开发人员以外的人必须根据其实现来推断对象或操作的目的，新的开发者可能会推断出一个意图——操作或类只是偶然地执行。如果这不是意图的话，那么代码可能暂时有效，但设计的概念基础已经被破坏了，两个开发人员将在交叉目的下工作。

　　因此：

　　**命名类名和操作名来描述它们的效果和目的，而不用参考它们做出履约的方法。这减轻了客户开发者理解内部的必要性。这些名字应符合通用语言，以便团队成员可以快速推断其含义。在创建它之前为行为编写一个测试，以强制您的思维进入客户端开发人员模式。**

## 无副作用方法

　　多个规则或计算的组合的相互作用变得非常难以预测。开发人员调用一个操作必须理解它的实现以及所有委托的实现，以便预测结果。如果开发人员被迫刺破遮罩层，任何抽象接口的用处都是有限的。如果没有安全可预测的抽象，开发人员必须限制组合爆炸，对可行的丰富行为设置较低的上限。

　　因此：

　　**将尽可能多的程序逻辑放入函数中，返回没有明显副作用的结果。严格地将命令（引起明显的状态改变的方法）分隔成不返回领域信息的非常简单的操作。当发现了一个符合职责的概念时，通过将复杂的逻辑转化为值对象来进一步控制副作用。**

　　**值对象的所有操作都应该是无副作用的函数。**

## 断言

　　当操作的副作用只是通过实现而隐含地定义时，大量委托的设计就会成为一种混乱的因果关系。理解程序的唯一方法是通过分支路径来跟踪执行。封装的价值失去了。跟踪具体执行的必要性使抽象也失败了。

　　因此：

　　**状态操作的后置条件以及类和聚合的不变性。如果断言不能直接用你的编程语言编写，请为它们编写自动单元测试。将它们写入符合项目开发过程风格的文档或图表中。**

　　寻找具有相关概念集的模型，这些概念引导开发人员推断预期的断言，加速学习曲线并降低矛盾代码的风险。

　　断言定义了服务和实体修饰符的契约。

　　断言在聚合上定义了不变性。

## 孤立类

　　即使在同一个模块中，随着依赖性的增加，解释设计的难度也会大幅增加。这增加了理解的负担，限制了开发人员可以处理的设计复杂性。隐式概念对此负担的促进作用甚至超过了显示的引用。

　　**低耦合是面向对象设计的基础。如果可以，一直这样做。消除图中的所有其他概念。然后类将完全独立，可以单独研究和理解。每个这样的自包含类都显着减轻了理解一个模块的负担。**

## 闭合操作

　　大多数有趣的对象最终都只能做一些无法用基本元素来表示的东西。

　　因此：

　　**在适当的情况下，在定义操作时让它返回类型与其参数的类型相同。如果实现者的状态在计算中会被用到，那么实现者实际上就是操作的一个参数，因此参数和返回值应该与实现者有相同的类型。这种操作就是在该类型的实例集合中的闭合操作。闭合操作提供了一个高层接口，而不会引入对其他概念的依赖。**

　　这种模式通常应用于值对象的操作。因为一个实体的生命周期在领域中具有重要意义，所以你不能创造一个新的实体来回答一个问题。也有一些操作在实体类型下闭合。可以向其主题对象请求一个属性对象并取回另一个属性。但总的来说，实体并不是那种适合成为计算结果的概念。所以，大多数情况下，这是一个寻找值对象的机会。

　　你有时会陷入这种模式的一半。参数与实现者匹配，但返回类型不同，或者返回类型与接收者匹配，参数不同。这些操作并不是闭合的，但是他们给与了思考闭合的一些优势的想象空间。

## 声明式设计

　　在程序软件中不可能有真正的保证。仅以一种逃避断言的方式命名，代码可能会产生额外的副作用而这些副作用并没有被排除在外。无论我们的设计如何以模型为导向，我们仍然最终编写程序来产生概念上的交互效果。并且我们花费大部分时间在编写样板代码上，而这些代码并没有实际增加任何意义或者行为。本章中的释意接口和其它模式有所帮助，但是它们不可能给传统的面向对象提供形式上的严谨。

　　这些是声明式设计背后的动机。这个术语对很多人来说意味着许多东西，但通常它指示一种编写一个程序或者程序的某个部分的方式，作为一种可执行的规范。对属性的非常精确的描述实际控制着软件。在它的各种形式中，可以通过反射机制或编译时通过代码生成来完成(基于声明自动生成传统代码)。这种方法允许其他开发人员以表面价值接受声明。这是一个绝对的保证。

　　如果开发人员有意或无意地绕过它们，很多声明式方法可能会被破坏。当系统难以使用或限制过多时，这很可能发生。每个人都必须遵守框架的规则才能获得声明式编程的好处。

### 一种声明式的设计风格

　　一旦你的设计有释意接口，无副作用函数和断言，你就会进入声明式领域。声明式设计的许多好处都是在您具有可交流其含义的可组合元素，并且具有特征或明显效果，或根本没有可观察效果时获得的。

　　柔性设计可以使客户端代码使用声明式的设计风格成为可能。为了说明这一点，下一节将介绍本章中的一些模式，以使规范更加灵活和声明性。

## 图上的形式主义（形式化的绘画）

　　从零开始创建一个严格的概念框架是你每天都不能做的事情。有时在项目的生命周期中，您会发现并改进其中的一个。但是你可以经常使用和调整那些长期在你的领域或其他领域建立起来的概念系统，其中一些已经经过了几个世纪的精炼和提炼。例如，许多商业应用程序都涉及会计。会计定义了一套完善的实体和规则，可以轻松适应深层模型和柔性设计。

　　有许多这样的形式化的概念框架，但我个人最喜欢的是数学。让人惊讶的是，在基本算法上做一些改变是多么有用。很多领域包括数学。寻找它。挖出来。专业的数学是干净的，可以通过清晰的规则组合起来，并且人们发现它很容易理解。

　　在本书的第8章讨论一个真实世界的例子“Shares Math”，领域驱动设计。

## 概念轮廓

　　有时人们会为了灵活的组合而砍掉一些功能。有时候他们会把它封装得很复杂。有时他们会寻求一致的粒度，使所有类别和操作达到相似的程度。这些都是过于简单化的，不像一般规则那样有效。但是他们通过基本问题来激发。

　　当模型或设计的元素被嵌入到一个整体结构中时，它们的功能会被复制。外部接口并不表示客户端可能关心的所有内容。他们的意思很难理解，因为不同的概念是混合在一起的。

　　相反，分解类和方法可能会使客户端无意识去复杂化，迫使客户端对象了解如何将小块组合在一起。更糟糕的是，一个概念可能完全丧失。铀原子的一半不是铀。当然，重要的不是颗粒度的小大，但这只是颗粒度的来源。

　　因此：

　　**将设计元素(操作、接口、类和聚合)分解为内聚单元，同时考虑到您对领域重要分支的直觉。通过连续的重构观察核心的变化和稳定性，并寻找解释这些切分方式的基本概念轮廓。对比模型与领域一致的方面，首先让它成为一个可行的知识领域。**

　　基于深度模型的柔性设计产生了一组简单的接口，这些接口逻辑上可以在通用语言中作出合理的声明，并且没有无关选项的干扰和维护负担。





# [译文]Domain Driven Design Reference（五）—— 为战略设计的上下文映射


**绑定上下文**

　　对一个特定模型的定义和适用范围(通常是一个子系统，或特定团队的工作)的描述。

### 上游-下游

　　两个组之间的关系是“上游”小组的行为影响“下游”小组的项目成功。但下游的行为并不会显著影响上游项目。（例如，如果两个城市沿着同一条河流，上游城市的污染主要影响下游城市。）

　　上游团队可以独立于下游团队的命运而取得成功。

### 相互依赖

　　必须在不同的上下文中交付两个软件开发项目以使其中任何一个被认为是成功的情况。（当两个系统各自依赖另一个系统的信息或功能时，我们通常会尽量避免将看到的项目构建成相互依赖的。 然而，也有一些相互依赖的项目，系统依赖性只向一个方向发展。当依赖系统没有其它的系统与该系统的集成时，它几乎没有任何价值，或许因为这是唯一一个使用它的地方，那么未能提供依赖系统就会导致两个项目都失败。）

### 自由

　　一个理想中的软件开发上下文，在其它上下文中的开发工作是成功或失败对其自己的交付没有什么影响。

## 上下文映射

　　为了策划战略，我们需要一个现实的，大范围的模型开发视图，扩展到我们的项目和我们整合的其他项目。

　　在没有全局视图的情况下，个别限界上下文会遗留下一些问题。其他模型的上下文可能仍然是模糊不清的。

　　其他团队的人不会意识到上下文的界限，并且会在不知不觉中做出一些模糊边缘或使内部连接复杂化的改变。当连接必须在不同的上下文中进行时，它们往往会相互渗透。

　　即使边界清晰，与其他上下文的关系也会限制模型的性质或可行的变化速度。这些制约因素需要通过非技术渠道表现出来，有时很难与他们正在影响的设计决策联系起来。

　　因此：

　　**识别项目中正在使用的每个模型并定义它的限界上下文。这包括非面向对象子系统的隐式模型。给每个限界上下文命名，并且使其名称成为通用语言的一部分。**

　　**描述模型之间的联系点，列出对任何交互的明确翻译，突出任何共享、隔离机制和影响程度。**

　　**映射现有的领域范围。稍后再进行转换。**

  这张映射图可以成为实际设计策略的基础。

　　在接下来的几页中，关系的描述会变得更加具体，在限界上下文之间有一组通用的关系模式。

## 合作关系*

　　*当两个上下文中的团队共同成功或失败时，通常会出现合作关系。*

　　在相互独立的上下文中，相互依赖的子系统缺少协作会导致两个项目的交付失败。一个系统缺失的一个关键特性可能会使另一个系统无法交付。不符合其他子系统开发人员期望的接口可能导致集成失败。一个相互约定的接口可能会变得过于别扭，以致于减慢了客户端系统的开发速度，或者很难实现，从而减慢了服务端子系统的开发速度。失败带来了两个项目的失利。

　　因此：

　　**如果两个上下文中的任何一个开发失败都将导致两个上下文的交付一起失败，则在负责这两个上下文的小组之间建立合作关系。制定协调发展和联合管理一体化的过程。**

　　**团队必须在其接口的演进上进行协作，以适应这两个系统的开发需求。应该安排相互依赖的feature，以便它们在同一版本中完成。**

　　大多数情况下，开发人员不需要详细了解其他子系统的模型，但他们必须协调他们的项目计划。当一个上下文中的开发遇到障碍时，则需要联合研究这个问题，以找到一种紧急的设计解决方案，而不会过分地损害任何一方。

　　此外，还需要一个清晰的过程来管理集成。例如，可以定义一个特殊的测试套件，以证明接口符合客户端系统的期望，它可以作为服务器系统上持续集成的一部分运行。



## 共享内核

　　*共享模型和相关代码的一部分是非常密切的相互依赖关系，它能够加快设计工作或者破坏这些共享的东西。*

　　当功能集成受到限制时，大型上下文的持续集成的开销可能会被认为太高。当团队没有足够的技能或组织架构来维持持续集成，或者单个团队的规模太大而笨拙时，这种情况可能尤为明显。因此，可以定义独立的限界上下文，并形成多个团队。

　　一旦独立的、不协调的团队在密切相关的应用程序上工作，可能会向前推进一段时间，但是他们生产的产品可能不适合在一起。即使是合作伙伴团队最终也会花费大量精力在翻译层和改造上，同时重复这些工作并失去通用语言的好处。

　　因此：

　　**用明确的边界指定团队同意分享的领域模型的一部分子集。保持这个内核尽可能的小。**

　　**在这个边界内，包括模型的子集，代码的子集，或者与该模型的部分相关联的数据库设计。这种显式共享的内容具有特殊的地位，在未与其他团队协商的情况下不应改变。**

　　定义一个持续集成过程，以保持内核模型的紧凑性，并与团队的通用语言保持一致。经常其整合功能系统，虽然比团队中持续集成的次数要少一些。

## 客户/供应商开发

　　*当两个团队处于上下游关系时，上游团队可能独立于下游团队的命运而取得成功，下游的需求将以各种各样的方式得到解决，并带来广泛的负面后果。*

　　下游的团队可能是无助的，受上游优先级的摆布。与此同时，上游团队可能会收到抑制，担心会破坏下游系统。拥有复杂审批流程的繁琐的变更请求过程并没有改善下游团队的问题。如果下游团队对变更拥有否决权，上游团队的自由发展就会停止。

　　因此：

　　**在两个团队之间建立清晰的客户/供应商关系，意味着将下游优先因素放到上游的规划中。为下游需求进行谈判和预算任务，以便每个人都了解承诺和时间表。**

　　敏捷团队可以在规划会议中让下游团队扮演上游团队的客户角色。联合开发的自动化验收测试可以验证来自上游的预期接口。将这些测试添加到上游团队的测试套件中，作为其持续集成的一部分，将使上游团队自由地进行更改，而不必担心下游的副作用。

## 顺从者

　　当两个开发团队有一个上下游关系时，上游没有动力为下游团队的需求提供帮助，下游团队就无能为力了。利他主义可能会促使上游开发者做出承诺，但它们不太可能实现。相信这些好意会导致下游团队基于无法获得的特性来制定计划。下游项目将被推迟，直到团队最终学会接受上游所提供的东西。针对下游团队的需求量身定制的接口是不太不可能的。

　　因此：

　　**通过对上游团队的模型进行严格的遵守，消除了限界上下文之间的转换的复杂性。尽管这限制了下游设计人员的风格，并且可能不会产生应用程序的理想模型，但是选择一致性极大地简化了集成。此外，你将与上游团队共享一种通用语言。上游在驾驶员的位置上，所以让他们的交流变得容易是件好事。利他主义可能足以让他们与你分享信息。**

## 反腐层

　　*当与合作团队衔接良好设计的限界上下文时，翻译层可以是简单的，甚至是优雅的。但是，当控制或通信不足以实现共享内核、合作伙伴或客户供应商关系时，转换就变得更加复杂。翻译层采用了一种更具防御性的语气。*

　　一个提供给上游系统的大型接口最终可能完全颠覆下游模型的意图，从而使其被修改成以一种特别的方式来模仿其他系统的模型。遗留系统的模型通常是很薄弱的(如果不是大泥球的话)，即使是明确设计的例外也可能不符合当前项目的需求，这使得遵循上游模型变得不切实际。然而，这种集成对于下游项目可能非常有价值甚至是必需的。

　　因此：

　　**作为下游客户端，创建一个隔离层，根据您自己的领域模型，为系统提供上游系统的功能。该层通过其现有的接口与另一个系统进行通信，只需要很少或不需要对其他系统进行修改。在内部，这一层在两个模型之间需要单向或双向转换。**

## 开放主机服务

　　*通常对于每个限界上下文，您将为每个部件定义一个翻译层，您必须将其与上下文之外的组件集成在一起。在集成是一次性的情况下，为每个外部系统插入翻译层的这种方法以最小的成本避免了模型的损坏。但是当你发现你的子系统有更高的要求时，你可能需要更灵活的方法。*

　　当一个子系统必须与许多其他的子系统集成时，为每一个子系统定制一个翻译对象可能会使团队陷入困境。有越来越多的维护，越来越多的担心什么时候会发生变化。

　　因此：

　　**定义一个协议，将访问您的子系统作为一组服务。 打开协议，使所有需要与您集成的人都可以使用它。增强和扩展协议以处理新的集成需求，除非一个团队有特殊的需求。然后，使用一次性翻译对象来增强该特殊情况的协议，以便共享协议能够保持简单和一致。**

　　这将使服务提供者处于上游位置。每个客户端都在下游，并且通常其中一些客户端会遵守规定，有些客户端会建立反腐层。具有开放主机服务的上下文可能与它的客户端以外的上下文有任何关系。

## 公共语言

　　*两个限界上下文模型之间的转换需要一种通用语言。*

　　直接转换到现有的领域模型可能不是一个好的解决方案。这些模型可能过于复杂或被分解得很糟糕。也许他们说的是非法的。如果将其中一种用作数据交换语言，它实际上就会被冻结，不能响应新的开发需求。

　　因此：

　　**使用一种文档完整的公共语言，可以将必要的领域信息作为一种通用的通信媒介来表达，并根据需要翻译为该语言。**

　　许多行业以数据交换标准的形式建立了公共语言。项目团队也开发自己的，在他们的组织内使用。

　　公共语言通常与开放主机服务相结合。

## 分而治之

　　在定义需求方面，我们必须冷酷无情。如果两组功能之间没有显著的关系，它们可以完全相互分离。

　　整合总是代价很大的，有时候好处很小。

　　因此：

　　**声明一个限界上下文，使其与其他上下文完全没有关联，允许开发人员在这个小范围内找到简单的、专门的解决方案。**

## 大泥球

　　在我们调查现有的软件系统时，我们试图了解不同的模型在定义的边界内是如何被应用的，我们发现部分系统（通常是大型系统），模型是混合的，边界是不一致的。

　　在没有边界的系统中，试图描述模型的上下文边界很容易陷入困境。

　　定义良好的上下文边界作为知识选择和社会力量的结果出现(尽管创建系统的人在当时可能并不总是有意识地意识到这些原因)。当这些因素缺失或消失时，将多个概念系统混合在一起，使得定义和规则变得模棱两可或相互矛盾。随着特性的添加，系统是根据附加的逻辑来工作的。依赖关系纵横交错。因果关系变得越来越难以追踪。最终，软件会凝结成一个大的泥球。

　　在某些情况下，大球泥实际上是非常实用的（正如Foote和Yoder的原文所描述的那样），但它几乎完全阻止了有用模型所需要的敏锐和精确性。

　　因此：

　　**在整个混乱的周围画一个边界，把它指定为一个大泥球。不要尝试在此上下文中应用复杂的建模。要警惕这种系统向其他上下文蔓延的趋势。**

　　（见http://www.laputan.org/mud/mud.html。Brian Foote和Joseph Yoder）

# [译文]Domain Driven Design Reference（六）—— 提炼战略设计

> 本书是Eric Evans对他自己写的《领域驱动设计-软件核心复杂性应对之道》的一本字典式的参考书，可用于快速查找《领域驱动设计》中的诸多概念及其简明解释。



　　你如何专注于你的核心问题，并避免陷入一大堆细枝末节？

　　提炼是是一种分离混合物成分的过程，以提取出一种使其更有价值和有用的形式。模型是知识的提炼。随着每一次重构的深入，我们抽象出领域知识和优先级的一些关键方面。现在，回过头来看战略视角，本章将探讨如何区分模型的涉猎范围并提炼整个领域模型。



## 核心领域

　　在一个大型系统中，有太多的合作组件，一切都很复杂，但都是成功的必要条件，所以领域模型的本质，真正的商业资产，可能会被掩盖和忽略。

　　残酷的现实是，并非所有设计的部分都要同样的精炼。优先事项必须确定。为了使领域模型成为一种资产，该模型的关键核心必须是整洁且充分利用来创建应用程序功能。但是缺乏丰富经验的开发者倾向于对技术基础设施或者可清晰定义的领域问题感兴趣，这些问题可以在没有专门领域知识的情况下被理解。

　　因此：

　　**归纳模型。定义一个核心域，并提供一种可以很容易区分支持模型和代码的方法。让最有价值和最专业的概念显露出来。**

　　**将顶尖人才应用到核心领域，并据此招聘。在核心中花费精力寻找一个深层的模型，并开发一个柔性设计来实现系统的远景。**

　　通过如何支持提炼出来的核心来证明对其他任何部分的投资是合理的。



## 通用子域

　　模型的某些部分增加了复杂性，而没有捕获或传播专业知识。任何无关紧要的东西都会使核心领域更难识别和理解。这个模型符合所有人都知道或者是属于专业的一般原则，这些原则不是你的主要关注点，而是发挥辅助作用。然而，这些其他的元素对于系统的功能和模型的完整表达都是必不可少的。

　　因此：

　　**识别不是你的项目动机的内聚子域。提取出这些子域的通用模型，并将它们放在单独的模块中。不要留下你的特点。**

　　**一旦它们被分离，将它们的后续开发优先级置于核心领域之下，并避免你的核心去做这些任务（因为这些核心开发将从他们那里获得很少的领域知识）。还要考虑这些通用子域的现成解决方案或已发布的模型**。



## 领域愿景宣言

　　在项目开始时，模型通常是不存在的，但是关注其发展的需求已经存在。在开发的后期阶段，需要对系统的价值进行解释，而不需要对模型进行深入研究。此外，领域模型的关键方面可能跨越多个限界上下文，但是根据定义，这些不同的模型不能被构造来显示它们的共同焦点。

　　因此：

　　**写一个关于核心领域的简短描述（大概一页）以及它将带来的价值，即“价值主张”。忽略那些不区分该领域模型和其它东西的方面。显示领域模型如何服务和平衡多种利益。保持它的精简。尽早写下此声明，并在获得新见解时对其进行修改。**



## 突出核心

　　*领域愿景宣言以广义的术语来标识核心领域，但是它将特定的核心模型元素的识别留给了个体的解释。除非团队中的沟通水平非常高，否则单凭愿景宣言没有多大影响。*

　　即使团队成员大致知道什么是核心领域，但不同的人不会挑出相同的元素，即使是同一个人，在不同的时间点做出的选择也不一定是一致的。不断过滤模型以识别关键部分的脑力劳动更好地将注意力集中在设计思维上，并且需要对模型有全面的认识。必须使核心域更容易看到。

　　对代码进行重大的重构是识别核心领域的理想方式，但它们在短期内并不总是实用的。事实上，如果没有团队所缺乏的观点，这种重大的代码重构就很难进行。

　　因此（作为突出核心的一种形式）：

　　**编写一个非常简短的文档(3到7个简单页面)，描述核心领域和核心元素之间的主要交互。**

　　和/或（作为突出核心的另一种形式）：

　　**在模型的主存储库中标记核心领域的元素，而不是特别地试图阐明其角色。让开发人员轻松了解核心的内外内容。**

　　如果浓缩文件概括了核心领域的要点，那么它就可以作为一个实际的指标，说明模型变更的重要性。当模型或代码变更影响到浓缩文档时，需要与其他团队成员协商。当更改完成时，需要立即通知所有团队成员，并传播新版本的文档。除核心外的变更或未包含在浓缩文档中的细节，可以不经协商或通知的情况下进行而集成，并且其他成员在其工作过程中也会遇到。然后开发人员拥有绝大多数敏捷过程所建议的自主权。

　　*尽管有愿景宣言和突出的核心信息和指南的存在，但是它们实际上并没有修改模型或代码本身。划分通用子域将从物理上去除一些分散注意力的元素。接下来，我们将研究其它方式来结构性地更改模型和设计本身，以使核心领域更易理解和管理。。。*



## 内聚机制

　　开始膨胀设计使得计算有时会达到一个复杂程序。概念性的”做什么”被机械的”如何做”所淹没。提供解决问题算法的大量方法模糊了表达问题的方法。

　　因此：

　　**将概念上的内聚机制分离到一个单独的轻量级框架。特别注意形式主义或有良好文档的算法类别。用意图揭示接口来公开框架的功能。现在，领域中的其他元素就可以只专注与如何表达问题（做什么）了，而把解决方案的复杂细节（如何做）转移给了框架。**

　　**分解通用子域会减少混乱，而内聚机制有助于封装复杂的操作。这就留下了一个更专注的模型，减少了对用户进行活动的方式没有特别价值的这类干扰。但是，你不可能在没有核心的领域模型中找到好的结果。分离的核心是采取直接的方式来结构化地标记出核心领域。。。**



## 隔离核心

　　模型中的元素可能部分服务于核心领域，并且部分扮演辅助角色。核心元素可能与通用元素紧密耦合。核心的概念性内聚力可能不强或缺失。所有这些混乱和复杂关系扼杀了核心。设计师不能清楚地看到最重要的关系，导致设计薄弱。

　　因此：

　　**对模型进行重构，把核心概念从支持性元素（包括定义得不清楚的那些元素）中分离出来，并增强核心的内聚性，同时减少它与其他代码的耦合。把所有通用元素或支持性元素提取到其他对象中，并把这些对象放到其他的包中，即使这会把一些紧密耦合的元素分开。**



## 抽象核心

　　即使是核心领域模型通常也有很多细节，因此沟通大局面可能是困难的。当单独模块中的子域之间存在很多交互时，要么在模块之间创建许多引用，要么就会破坏分区的大部分价值，否则交互将不得不间接地进行，这使得模型变得模糊。

　　因此：

　　**确定模型中最基本的区分概念，并将它们分为不同的类，抽象类或接口。设计这个抽象模型，以表达大部分重要组件之间的交互。将这个抽象的整体模型放在它自己的模块中，而专门的、具体的实现类留在由子域定义的它们自己的模块中。**





# [译文]Domain Driven Design Reference（七）—— 大型战略设计结构

> 本书是Eric Evans对他自己写的《领域驱动设计-软件核心复杂性应对之道》的一本字典式的参考书，可用于快速查找《领域驱动设计》中的诸多概念及其简明解释。



　　在一个大的系统中，没有任何能够让元素按照其在整个设计模式中的角色来解释它们，好比是开发人员无法看到树木的森林。我们需要能够理解个体在整体中的角色，而不需要深入研究整体的细节。

　　“大规模结构”是一种语言，可让您广泛地讨论和理解系统。一组高级概念或规则，或两者都为整个系统建立了设计模式。这个组织原则可以指导设计和帮助理解。它有助于协调独立的工作，因为有一个共同的概念:各个部分的角色如何塑造整体。

　　因此：

　　**设计一种规则或角色和关系的模式，它将跨越整个系统，并且在不详细了解该部分责任的情况下，允许对整个系统中的每个部分进行一些理解。**



## 演化有序

　　无设计的生产系统是没有人能理解整体的，而且它们很难维护。但是，架构可以用预先设计的假设来约束一个项目，并且从应用程序特定部分的开发人员/设计人员那里获得大量权力。很快，开发人员就会降低应用程序以适应结构，或者他们会破坏这个结构，并且根本就没有任何结构，这就导致了不协调开发的问题。

　　因此：

　　**让这个概念性的大型结构与应用程序一起演进，可能会在过程中变成一种完全不同的结构类型。不要过度限制详细的设计和模型决策必须要有详细的知识。**

　　当一个结构可以被发现的时候，就应该采用大规模结构【这2句不是很顺，但也没办法了】，这样就能在不违反模型开发的前提下，大大澄清系统。因为一个不合适的结构比没有更糟糕，所以最好不要选择全面性，而是寻找一个最小的集合来解决已经出现的问题。少即是多。

　　接下来是在一些项目中出现的四种特定模式的大规模结构，它们是这种模式的代表。



## 系统隐喻

　　隐喻思维在软件开发中非常普遍，特别是对于模型。但是，“隐喻”的极限编程实践，使用隐喻为整个系统的发展带来秩序已经成为一种特殊的方式。

　　软件设计往往是非常抽象和难以理解的。开发人员和用户都需要切实的方法来理解系统，并共享整个系统的视图。

　　因此：

　　**当一个与系统的具体类比出现时，它抓住了团队成员的想象力，并且似乎将思维导向有用的方向时，把它作为一个大规模结构。围绕这个隐喻组织设计，并将其吸收到通用语言中。系统隐喻既能促进关于系统的交流，又能引导系统的发展。这增加了系统不同部分的一致性，甚至可能跨越不同的限界上下文。**



## 职责层

　　在面向对象的设计中，每个对象都被分配了一系列的相关职责。责任驱动设计也适用于较大规模。

　　当每个单独的对象都有手工制定的职责时，没有指导原则，不统一，也没有能力一起处理大范围的领域。为了实现一个大型模型的一致性，对这些责任的分配施加一些结构是有用的。

　　因此：

　　**查看模型中的概念依赖关系，以及领域不同部分的变化率和变化源。如果你确定了领域中的自然层次，就把它们作为宽泛的抽象职责。这些职责应该讲述一个关于您的系统的高级目标和设计的故事。重构模型，使每个领域对象、聚合和模块的职责完全符合一个层的职责。**



## 知识层次

　　一组描述另一组对象应该如何表现的对象。

　　在一个应用程序中，实体之间的角色和关系在不同的情况下有所不同，复杂性可能会爆炸。既不是完全通用的模型，也不是用户需要的高度定制的模型。对象最终引用其他类型来涵盖各种情况，或者在不同情况下以不同方式使用的属性。具有相同数据和行为的类可能只是为了适应不同的程序集规则而组装。

　　因此：

　　**创建一组可用于描述和约束基本模型的结构和行为的独特对象。将这些关注点分为两个“层次”，一个非常具体，另一个反映用户或超级用户能够自定义的规则和知识。**

　　（见Fowler，M.1997。分析模式：可重复使用的对象模型，Addison-Wesley。）



## 可插拔组件框架

　　机会出现在一个非常成熟的模型中，并且是深入和精炼的。一个可插拔组件框架通常只有在几个应用程序已经在同一个领域中实现之后才开始发挥作用。

　　当各种应用程序必须互操作时，所有的应用程序都基于相同的抽象，但是独立地设计，在多个有界的上下文之间的转换会限制集成。对于不紧密协作的团队来说，共享内核是不可行的。复制和碎片化增加了开发和安装成本，互操作性变得非常困难。

　　因此：

　　**提炼接口和交互的抽象核心，并创建一个允许这些接口的各种实现自由替换的框架。同样，允许任何应用程序使用这些组件，只要它严格地通过抽象核心的接口进行操作即可。**


原创文章，转载请注明本文链接: **[https://zacharyfan.com/archives/284.html](https://zacharyfan.com/archives/”https://zacharyfan.com/archives/284.html”)**


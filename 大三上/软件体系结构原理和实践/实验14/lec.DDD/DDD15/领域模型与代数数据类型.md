# 领域模型与代数数据类型





*《领域驱动设计15年》第8章*

*作者：Scott Wlaschin*[[1\]](https://zhuanlan.zhihu.com/p/127128213#ref_1)

*译者：封小武*

*校审：覃宇、伍斌*



> *作者评语：很荣幸能为本书撰写文章。虽然《领域驱动设计》一书出版已经有十五个年头了，但书中的洞见和智慧历久弥新，持续影响着一代又一代的程序员新人。但自 Evans 落笔那一刻开始，变化已经悄然发生——函数式编程逐渐兴起，成为了和面向对象编程并驾齐驱的编程范式。函数式编程的文章大多侧重数学理念，但我认为，将函数式编程和领域驱动设计的原则结合起来，很有可能产生有效的设计。我将我撰写的《Domain Modeling Made Functional》一书浓缩成一章来解释这背后的原因。*

促进**开发团队、领域专家与其他干系人**之间的顺畅交流是**领域驱动设计**的主要目标之一。实际上，实现代码差不多应该和领域专家的心智模型一一对应。也就是说，如果领域专家将某个事物称为“Order”，那代码就中就应该也有一个“Order”术语，而且它的行为要和专家口中的“Order”一致。反过来说，我们的代码中不应当包含领域专家的模型中**没有**体现的事物。这意味着像“OrderFactory”、“OrderManager”、“OrderHelper"这样的术语不应该出现。当然，代码库中难免会出现一些技术术语，但是我们应该**避免暴露**这部分设计。

于是挑战来了：我们的代码到底和领域有多匹配？我们能够创造出读起来像文本一样的代码，让非开发人员也能理解吗？我们能够避免引入像“Manager”和“Factory”这样的非领域术语吗？我认为在领域建模过程中使用**代数数据类型**可以解决所有这些问题。

## 1. 发现领域建模中的常见概念

当我们还在探索阶段和领域专家交谈的时候，常常会听到关于领域的口头描述。例如：

- “订单行包含订单编号、产品编号以及订购数量”
- “联系信息由人名和联系方式组成，联系方式可以是邮箱地址，也可以是电话号码”
- “邮箱可能经过了验证也可能没有经过验证。经过验证的邮箱才可以接收密码重置邮件”
- “买家可能是一次性‘访客’，也可能已经在网站上注册了。注册过的买家会被分配一个客户编号，而一次性访客没有客户编号”
- “结账时，先看到的是未支付的账单和支付信息，最后得到的是已经支付过的账单”

我们将基于这些和有关领域的描述来构建统一语言，一些常见的模式会在这个过程中浮现出来，我们可以对这些模式进行**分类**：

- 基本类型的值
- 被视为整体的一组事物
- 事物之间的选择
- 工作流（还有用例、场景等其它叫法）
- 状态和生命周期

接下来我们将深入每一种模式，探讨它们的细节。

### 1.1. 基本类型的值

领域专家从不会说“整型”或者“字符串”。他们会使用像“订购数量（Order Quantity）”或“邮箱地址（Email Address）”这样的领域概念。这些概念可以用一个整型或者一个字符串表示，但是它们并不是等价的。例如，“订单编号（Order Id）”、“产品编号（Product Id）”以及“订购数量”也许都可以用整数表示，但是领域概念绝不等同于整数。例如，“订单编号”乘以 2 没有任何道理。

即便概念就是整数也不能直接和编程语言中的 int 对应——**几乎不可能没有约束**。例如，“订购数量”必须至少为 1，而且还可能存在上限，比如 100。销售系统不可能允许订购 20 亿件产品！

同样，“邮箱地址”和“电话号码（Phone Number）”都可以用字符串表示，但也不可互换，而且这两个概念都要满足特定的约束。

如果我们用文档来记录这些基本类型的值，可能会这样写：

```text
data OrderId              // 字面无意义 -- 表现形式不重要
data ProductId            // 字面无意义 -- 表现形式不重要
data OrderQuantity is int // 大于等于 1 小于等于 100
data PersonalName is string // 不能为 null，也不能是空字符串，不能超过 100 个字符。
data EmailAddress is string // 不能为 null，也不能是空字符串，必须包含字符 @。
data PhoneNumber is string  // 不能为 null，也不能是空字符串，只能由数字、圆括号或者连接号
```

将上述记录转换成代码的时候，这些描述的**简单性**应当被保留下来。代码的表现形式应该尽可能贴近领域中的概念。

### 1.2. 被视为整体的一组事物

显然，有些领域概念的值不是基本类型，它们是由这些**较小的值组合而成**。对于这些类型的事物，我们在记录时会使用“AND”（和）将值组合在一起，比如：

```text
data OrderLine is OrderId AND ProductId AND OrderQuantity
data ContactInformation is PersonalName AND ContactMethod
```

## 2. 事物之间的选择

由**不同的选项**组成的概念是另一种常见的模式。

- “邮箱要么验证过（Validated），要么没验证过（Unvalidated）”
- “买家（Purchaser）要么是一次性‘访客’（Guest），要么是注册（Registered）用户”
- “账单（Invoice）要么未支付（Unpaid），要么已支付（Paid）”

我们可以使用“OR”（或）来记录这些情形，就像下面这样：

```text
data Email is UnvalidatedEmail OR ValidatedEmail
data ContactMethod is EmailAddress OR PhoneNumber
data Purchaser is GuestPurchaser OR RegisteredPurchaser (contains CustomerId)
data Invoice is UnpaidInvoice OR PaidInvoice
```

**这些选项概念往往是业务规则的关键**，一定要清楚地认识到这一点。例如：

- 只有 ValidatedEmail 才可以接收重置密码链接（而 UnvalidatedEmail 不能接收）。
- 只有 RegisteredPurchaser 才可以享受折扣（而 GuestPurchaser 无法享受）。
- 只能为 UnpaidInvoice 付款（而 PaidInvoice 不能付款）。

如果分不清不同选项之间的差别，只会得到含混模糊的设计，而最终的实现可能漏洞百出。

### 2.1. 克制采用类驱动设计的冲动

**持久化无关**是领域驱动设计的关键原则。这一原则非常重要，它强调将重点放在如何**准确地**对领域进行建模，**而不要去关注数据库中具体的数据表现形式**。实际上，经验丰富的面向对象开发者对这种不要被特定数据库模型左右设计的思想并不陌生，面向对象中的依赖注入等技术支持将数据库实现与业务逻辑分开。

但是，当我们在思考领域的设计时，要小心**别让对象和类**喧宾夺主，导致设计跑偏。例如，当领域专家谈起不同的联系方式时，你可能不由自主地在脑海里构思下面这样的类层级结构：

```text
// 代表全部联系方式
class ContactMethodBase ...    
// 代表邮箱联系方式
class EmailAddressContactMethod extends ContactMethodBase ...  
// 代表电话号码联系方式
class PhoneNumberContactMethod extends ContactMethodBase ...   
```

然而，让类来驱动设计和让数据库来驱动设计一样危险，这种方法也不能真正地抓住需求。

- 我们脑海里的类层级结构中引入了一个人为创造的基类 ContactMethodBase，它在现实世界中并不存在。这是对领域概念的曲解。问问领域专家知不知道 ContactMethodBase 是什么！
- 同样，EmailAddress 是可以重用的基本类型的值，它并不是一种特定的联系方式，因此我们不得不创建一个包装类 EmailAddressContactMethod，才能在当前特定的上下文里使用它。这又是一个在代码中人为创造的对象，它并不代表领域中的某个事物。

这里的经验是，在收集需求的时候保持开放的心态，**不要在领域概念上强加技术思想**。

### 2.2. 工作流

到目前为止，我们一直在讨论领域中的“名词”——数据结构。实际上，对模型来说最重要的并非是名词。为什么这么说呢?

业务不仅包含数据，还需要**转换**数据。也就是说，典型的业务流程可以被想象成一系列对数据和文档的转换。业务的价值在转换的过程中产生，因此理解这些转换如何工作、如何关联至关重要。

静态数据（放在那里从来不会用的数据）不提供任何价值。那么是什么让人（或者自动化流程）开始使用数据并创造价值呢？触发点通常来自外部（收到一封邮件或者接到一通电话），有的也来自时间（每天早上十点要做的某项工作），还有的来自观测（收件箱里已经没有待处理的订单了，该做其他工作了）。

无论是什么触发了流程，重要的是在设计中将它们体现出来。我们通常将这些触发点称为**领域事件**。我们要建模的业务流程几乎全部都是从领域事件开始。例如：

- “支付账单已接收”（Payment Received）是领域事件，它将启动“支付”（Applying Payment）工作流
- “邮箱验证链接已点击”（Email Validation Link Clicked）是领域事件，它将启动“验证邮箱”（Validate Email）工作流

在领域中探索并**发现事件**的方法有很多，其中**事件风暴**最适合领域驱动设计。Alberto Brandolini 创造的这种协作过程，可以发现业务事件以及与之相关的工作流。

假如我们已经识别出了有意义的事件，接下来就要把这些事件触发（Trigger）的工作流（或者用例）记录在案。我们尽量保持宏观，只用记下**每个工作流（Workflow）的输入（Input）和输出（Output）**，就像这样：

```text
workflow ApplyPaymentToInvoice =  
   triggered by: PaymentReceived
   inputs: UnpaidInvoice, Payment
   outputs: PaidInvoice    
 
workflow ValidateEmail =
   triggered by: EmailValidationLinkClicked
   inputs: UnvalidatedEmail, ValidationToken (from clicked link)
   outputs: ValidatedEmail OR an error
```

第二个例子中的邮箱验证工作流可能会失败（比如链接过期），因此存在不同的输出**选择**：要么是验证过的邮箱地址，要么是错误。

### 2.3. 状态和生命周期

重要的业务实体大多存在生命周期——它们会随着时间推移经历一系列变化。

- 账单刚开始是未支付的，然后转换为已支付的。
- 买家刚开始是访客，然后转换为已注册的。

即便是简单的值也可能经历状态的转换。例如，电子邮件地址一开始是未验证的，然后转换为已验证的。

**捕获状态以及状态之间的转换**是领域建模的一项重要工作。我们可以复用前面介绍的技术来捕获状态及其转换：用一组选项来表示不同的状态，用工作流表示状态之间的转换。例如，账单的状态及其转换可以这样记录：

```text
// 两种状态
data Invoice = UnpaidInvoice OR PaidInvoice
// 一种转换
workflow ApplyPaymentToInvoice =  
    transforms UnpaidInvoice -> PaidInvoice
```

这个例子里没有PaidInvoice 状态到 UnpaidInvoice 状态的转换。这种转换应该存在吗？从状态和生命周期的角度进行思考是一种不错的方法，它能激发出关于设计的富有成效的讨论。

## 3. 理解代数数据类型

我们回顾了领域建模的一些常见概念，接下来我们看看这些概念如何与代数数据类型代码映射。这一节我们会给出**代数数据类型**的定义。然后，我们将在下一节里看到如何运用它们来呈现领域模型。

### 3.1. 什么是代数数据类型？

在代数类型系统里，用较小的类型构建新类型的方式有两种：

- 用 *AND* 组合
- 用 *OR* 组合

然而，在建模这个上下文里，*AND* 和 *OR* 的含义到底是什么呢？

### 3.2. “AND” 类型

我们先用 *AND* 开始构建类型。例如，我们可以说制作一份水果沙拉（Fruit Salad）需要一个苹果（Apple），*和（AND）*一根香蕉（Banana），*和（AND）*一些樱桃（Cherry）。所有程序员都熟悉这种类型，它就是一个**记录**或者一个**结构体**。函数式程序员称之为**积类型***。*

下面是用 F# 定义的 FruitSalad 记录类型：

```csharp
type FruitSalad = {
  Apple : AppleVariety
  Banana : BananaVariety
  Cherries : CherryVariety
}
```

花括号表明这是一个记录类型，它有三个字段，分别是 Apple、Banana 和 Cherries。Apple 字段的值必须是 AppleVariety 类型，Banana 字段的值必须是BananaVariety 类型，等等。

### 3.3. "OR" 类型

另一种构造新类型的方式是使用 *OR*。例如，我们可以说一份水果点心（Fruit Snack）就是一个苹果，*或者（OR）*一根香蕉，*或者（OR）*一些樱桃。函数式程序员称之为**和类型**或者**可区别***联合*。这里我把它们称为**选择类型**，因为在领域中这种类型被用来表示选择。

下面是 F# 的 FruitSnack 定义：

```csharp
type FruitSnack =
 | Apple of AppleVariety
 | Banana of BananaVariety
 | Cherries of CherryVariety
```

选项与选项之间用竖线分开，每一种选项都必须使用标签（比如 Apple 和 Banana）。之所以要用标签进行区分，是因为有时侯存在两个或者多个相同类型的选项。上面的定义可以这样读：

- 一份 FruitSnack 是一个 AppleVariety（记为 Apple） *或者（OR）* 一个BananaVariety（记为 Banana）*或者（OR）* 一个 CherryVariety（记为 Cherries ）。

水果种类本身也被定义成选择类型，这和其他语言中的 enum 类似。

```csharp
type AppleVariety =
 | GoldenDelicious
 | GrannySmith
 | Fuji
 
type BananaVariety =
 | Cavendish
 | GrosMichel
 | Manzano
 
type CherryVariety =
 | Montmorency
```

这些类型可以读作：

- AppleVariety 是 GoldenDelicious *或者（OR）*GrannySmith *或者（OR）*Fuji。
- 其他的水果种类以此类推。

这些水果种类和 FruitSnack 有些不同，它们没有额外的数据——仅仅是标记而已。

### 3.4. 简单类型

我们经常需要定义只有一个选项的选择类型，例如：

```csharp
type EmailAddress =
 | EmailAddress of string
```

定义还可以像这样被简化成一行：

```csharp
type EmailAddress = EmailAddress of string
```

为什么需要创建这种类型？这是一种创建“包装器”的简单方法。“**包装器**”的内部只有一个基本类型的值，比如一个 string 或者一个 int。

例如，我们可能会定义下面这些包装器类型：

```csharp
type PersonalName = PersonalName of string
type EmailAddress = EmailAddress of string
type PhoneNumber = PhoneNumber of string
```

有了这些定义，我们就不会把这三种类型混为一谈。

### 3.5. 函数类型

最后还有一种类型需要讨论：函数类型。我们高中时就学过函数，它就像是一个黑盒，有输入，有输出。事物从一端进入函数，以某种方式进行转换，然后从另一端出来。

我们只需要记录函数的输入和输出，就可以对一个函数进行抽象的概括描述。例如，要记录一个将值加 1 的函数，我们会说这个函数接受一个 int 输入并将一个 int 作为输出返回，可以写成这样：

```csharp
type Add1 = int -> int
```

打头的是输入的类型，后面接着一个箭头，最后是输出的类型。

输入和输出可以是任意类型，当然也包括特定的领域类型在内。这意味着我们可以记录下面这个函数，它用 string 创建 EmailAddress 领域对象：

```csharp
type CreateEmailAddress = string -> EmailAddress
```

它可以读作：需要提供一个 string 给 CreateEmailAddress 作为输入，它的输出是一个 EmailAddress。

### 3.6. 代数类型是可组合的

现在我们可以给出代数类型*系统*的含义了。它就是一个类型系统，其中**每个**复合类型都是由较小的类型通过 *AND* 或者 *OR* 组合而成。使用 *AND* 和 *OR* 来构建新数据类型的方式似曾相识——我们之前记录领域概念时也使用了 *AND* 和 *OR*。

这种**可组合**的类型系统对于领域驱动设计**非常有帮助**，因为我们可以简单地使用不同的组合来组装类型，快速地创建出复杂的模型，我们马上就会看到。

## 4. 用代数数据类型来建模

万事俱备，现在我们可以开始真正的建模了。让我们回顾一下文章开头那些对领域的描述，使用代数数据类型来为它们建模。

### 4.1. 为订单行建模

描述是这样的：“订单行包含订单编号、产品编号以及订购数量”。

描述中有三种不同的特定于领域的基本类型，我们先定义三种类型：

```csharp
type OrderId = OrderId of int
type ProductId = ProductId of int
type OrderQty = OrderQty of int 
```

然后定义一个记录，用 AND 把它们组合起来。

```csharp
type OrderLine = {
  OrderId : OrderId
  ProductId : ProductId
  OrderQty : OrderQty
}
```

### 4.2. 为联系信息建模

描述是这样的：“联系信息由人名和联系方式组成，联系方式可以是邮箱地址，也可以是电话号码”。

这里又出现了三种“基本”领域类型：

```csharp
type PersonalName = PersonalName of string
type EmailAddress = EmailAddress of string
type PhoneNumber = PhoneNumber of string
```

接下来，我们可以定义一个选项是 EmailAddress 或 PhoneNumber 的选择类型。

```csharp
type ContactMethod =
 | ByEmail of EmailAddress
 | ByPhone of PhoneNumber
```

最后，我们把 PersonalName 和 ContactMethod 组合成一个记录：

```csharp
type ContactInformation = {
  Name : PersonalName
  ContactMethod : ContactMethod
}
```

### 4.3. 为买家建模

描述是这样的：“买家可能是一次性‘访客’，也可能已经在网站上注册了。注册过的买家会被分配客户编号，而一次性访客没有”

我们先定义两种不同的类型，分别代表两类访客，外加一个基本类型的 CustomerId：

```csharp
type GuestPurchaser = {
  Name : PersonalName
  ContactMethod : ContactMethod
}
 
type CustomerId = CustomerId of int
 
type RegisteredPurchaser = {
  Id: CustomerId
  Name : PersonalName
  ContactMethod : ContactMethod
}
```

然后，我们创建一个选择类型，它包括上面这两种选项。

```csharp
type Purchaser =
 | Guest of GuestPurchaser
 | Registered of RegisteredPurchaser
```

### 4.4. 为邮箱地址建模

描述是这样的：“邮箱可能经过了验证也可能没有经过验证。经过验证的邮箱才可以接收密码重置邮件”。

区分 Unvalidated 邮箱和 Validated 邮箱非常重要——它们有着不同的业务规则，因此我们应该要定义两种不同的类型来代表两种邮箱，再用它们组成选择类型：

```csharp
type UnvalidatedEmailAddress = UnvalidatedEmailAddress of string
type ValidatedEmailAddress = ValidatedEmailAddress of string
 
type EmailAddress =
  | Unvalidated of UnvalidatedEmailAddress
  | Validated of ValidatedEmailAddress
```

我们可以把重置密码的流程写成这样：

```csharp
type SendPasswordResetLink =
  ResetLinkUrl -> ValidatedEmailAddress -> output???
```

我们还不确定输出是什么，所以暂时不去定义。另外，邮件发送的细节（比如通过 SMTP 服务器发送）现在与领域模型还没什么关系，因此也不会在这里记录。

最后，我们可以将邮箱的验证过程记录如下：

```csharp
type ValidationToken = ValidationToken of string // 一个没有字面意义的 token
 
type ValidateEmailAddress =
  UnvalidatedEmailAddress -> ValidationToken -> ValidatedEmailAddress
```

上面这段代码读作：提供一个未经验证的邮箱地址和一个验证 token，我们就能得到一个已验证的邮箱地址。

### 4.5. 记录失败

但这里还存在问题，我们之前说过，验证操作可能失败。这就要在两种输出之间做出*选择*。如果一切顺利，得到的是 ValidatedEmailAddress；但如果出现错误，得到的则是某种错误消息。我们可以创建*另一种*代表验证结果的选择类型来解决这个问题：

```csharp
type ValidationResult =
 | Ok of ValidatedEmailAddress
 | Error of string
```

然后我们就可以使用 ValidationResult 作为验证流程的输出了，用它来代替

```csharp
 ValidatedEmailAddress。
type ValidateEmailAddress =
  UnvalidatedEmailAddress -> ValidationToken -> ValidationResult
```

如果我们想让可能发生的错误类型更加明确，可以使用另一种选择类型 ValidationError 来记录错误，然后在结果定义中使用这个类型：

```csharp
type ValidationError =
 | WrongEmailAddress
 | TokenExpired
 
type ValidationResult =
 | Ok of ValidatedEmailAddress
 | Error of ValidationError
```

这种表示“结果”的类型很常见，大多数函数式语言中都内建了类似的泛型类型，使用泛型的定义可能是：

```csharp
type Result<'SuccessType,'FailureType> =
 | Ok of 'SuccessType
 | Error of 'FailureType
```

如果使用内建类型，验证流程的函数定义如下：

```csharp
type ValidateEmailAddress =
  UnvalidatedEmailAddress -> ValidationToken -> Result<ValidatedEmailAddress,ValidationError>
```

上面的定义清楚地表达了验证可能会失败，以及可能出现的错误。而且，这是*代码*，不是文档，我们可以确保任何实现都能和设计准确地匹配。

### 4.6. 组合多个类型来勾勒领域模型

这种建模并不是“提前做大量设计”的重量级方法。恰恰相反，在与领域专家讨论时这种方法有助于齐心协力地绘制“设计草图”。

举个例子，假设我们要跟踪一家电子商务网站的支付业务。我们来看看如何在设计研讨时用代码描绘设计。

我们先从 CheckNumber 这样的基本类型包装器开始说起。它们就是前面讨论过的“基本类型”。使用包装器可以赋予它们有意义的命名，这样可以让它们更容易被其它领域模型理解。

```csharp
type CheckNumber = CheckNumber of int
type CardNumber = CardNumber of string
```

我们接下来深入地讨论一下信用卡（Credit Card），这可能需要创建更多低层级的类型。CardType 是 *OR* 类型——它要在 Visa *或（OR）*Mastercard 之间做出选择；CreditCardInfo 则是 *AND* 类型，它是一个包含 CardType *和（AND）*CardNumber 的记录：

```csharp
type CardType = Visa | Mastercard
 
type CreditCardInfo = {
  CardType : CardType
  CardNumber : CardNumber
}
```

我们了解到支付业务可以接受现金（Cash）、支票（Check）或信用卡（Card）三种支付方式，所以我们还需要再定义一个 *OR* 类型 PaymentMethod，它要在 Cash *或（OR）*Check *或（OR）*Card 之间作出选择。这不再是一个简单的“枚举”，因为有些选项有关联的数据：Check 要关联 CheckNumber，而 Card 则要关联 CreditCardInfo。

```csharp
type PaymentMethod =
 | Cash
 | Check of CheckNumber
 | Card of CreditCardInfo
```

接下来我们要讨论的是金额，它需要定义的类型更多了，比如 PaymentAmount 和Currency：

```csharp
type PaymentAmount = PaymentAmount of decimal // 必须是正数
type Currency = EUR | USD
```

最后才是位于最顶层的 Payment 类型，它是一个包含 PaymentAmount *和（AND）*Currency *和（AND）*PaymentMethod 的记录：

```csharp
type Payment = {
  Amount : PaymentAmount
  Currency: Currency
  Method: PaymentMethod
}
```

建模到此为止。我们只用了大约 25 行代码就完成了领域建模，而这些代码定义出了一组非常有意义的类型，它们具备实现的指导意义。

当然，这些类型没有直接相关的行为，因为它们是函数式的模型，不是面向对象的模型。要记录它们可以采取的操作，我们可以改用函数类型的定义。

例如，如果我们想要说明有这么一种方法，它可以使用 Payment 类型来支付未付款账单，最终得到的结果是支付过的账单，我们可能会定义出下面这个函数类型：

```csharp
type PayInvoice = UnpaidInvoice -> Payment -> PaidInvoice
```

这段代码可以读作：提供一个 UnpaidInvoice 和一个 Payment，就可以创建一个 PaidInvoice。

或者想要切换支付币种：

```csharp
type ConvertPaymentCurrency = Payment -> Currency -> Payment
```

第一个 Payment 是输入，第二个参数（Currency）是转换后的币种，第二个 Payment 是输出——是切换之后的结果。



## 5. 值对象、实体与聚合

现在我们对领域类型和工作流的建模有了基本的认识，我们继续讨论一种对领域对象分类的重要方法——领域对象是否具有永久的唯一标识。在领域驱动设计的术语里，具有永久唯一标识的对象被称为**实体（Entity）**，而没有永久唯一标识的对象被称为**值对象（Value Oibject）**。

### 5.1. 值对象

在许多情况下，我们所处理的数据对象可以**没有唯一标识，能够互相替换**。例如，一个值为“1234”的 CustomerId 实例，与具有相同值的其他 CustomerId 实例是一样的。我们不需要区别对待这两个实例，它们彼此相同。

当使用代数类型系统进行领域建模时，所创建的类型将自动实现这种基于字段的相等性测试。此时不需要自己动手编写任何特殊的相等性判断代码，这一点很不错。确切地说，在代数类型系统中，如果两个记录类型（同一类型）的所有字段都相等，那么记录本身也就相等。如果两个选择类型拥有的选项一样，并且选项关联的数据也相等，那么选择本身也就相等。这被称为**结构相等性**。

### 5.2. 实体

然而，我们确实经常要对现实世界中**具有唯一标识**的事物进行建模，即使这些事物的内部组件会发生变化。例如，即使改名或搬家，我这个人依然是同一个人。用领域驱动设计的术语来说，这类事物被称为**实体**。

在业务上下文里，实体通常是某种类型的文档：如订单、报价、账单、客户档案、产品报表等等。它们具有**生命周期**，并且在各种业务流程中从一种状态转换为另一种状态。

不管发生什么样的变化，实体都需要一个稳定的唯一标识。因此，在对它们进行建模时，需要为其提供唯一标识或键，如“Order Id”或“Customer Id”。例如，对下面这个UnpaidInvoice 类型来说，不管 AmountDue 字段怎么变，Id 字段会保持不变。

```csharp
type UnpaidInvoice = {
  Id: InvoiceId
  AmountDue : InvoiceAmount
}
```

显然，如果我们用不同的类型为生命周期中的状态建模，应该确保所有状态的标识字段相同。也就是说，下面 PaidInvoice 类型的 Id 必须和与之对应的 UnpaidInvoice 的 Id 相同：

```csharp
type PaidInvoice = {
  Id: InvoiceId
  AmountPaid : InvoiceAmount
  PaymentDetails : PaymentDetails
}
```

前面提到，默认情况下，代数类型系统的相等性比较会用到记录类型的所有字段。但是，在比较实体时，却只需要比较标识这一个字段。所以，必须改变默认的相等性比较行为，才能正确地为实体建模。

一种方法是创建自定义的相等性测试，**只对标识进行比较**。但在某些情况下，这种方法容易出错。因此，另一种更好的方法是**完全禁止对象的相等性测试**。

在 F# 中，可以像下面这样添加 NoEquality 类型注解来实现：

```csharp
[<NoEquality; NoComparison>]
type UnpaidInvoice = {
  Id: InvoiceId
  AmountDue : InvoiceAmount
}
```

当我们试图比较上面这个带有注解的类型的值的时候，就会产生编译错误。当然，我们仍然可以直接比较 Id 字段。这种使用 NoEquality 的方法的优势在于它消除了某个特定类型和相等性有关的所有歧义，促使我们明确相等性的含义。

## 6. 用不变性来辅助设计

在函数式编程语言里，代数数据类型默认是不可变的。也就是说前面定义的这些对象一旦初始化之后，将不能改变。

这会给设计带来哪些影响？

- **值对象**必须满足不可变性。想想我们在日常对话中如何使用值对象的吧。比如，一个人名如果部分发生了变化，那么我们会认为这是一个**新**的不同的人名，而不会认为这还是同一个人名，只不过是数据不同而已。值对象默认就是不可变的，这意味着值对象实现起来非常容易——什么都不用做。
- **实体**就是另一回事了。我们会期望与实体相关的数据会随着时间的推移而发生变化。而这就是实体必须拥有不变的唯一标识的原因。如何让不可变的数据结构做到这一点呢？答案是将数据更新后的实体复制一份**副本**，并保留其中的唯一标识。创建副本似乎需要很多额外工作，但实操中这不是问题。函数式编程语言自带对副本创建的支持，可以简化这个过程。

不可变数据结构带来的好处是，类型签名明确地说明了变更。例如，如果我们要编写一个修改 UnpaidInvoice 类型中 AmountDue 字段的函数，我们不能使用下面这种签名的函数（其中 unit 表示无输出）：

```csharp
type UpdateAmountDue = UnpaidInvoice -> AmountDue -> unit
```

上面这个函数没有输出，这说明它不会带来任何变化！要想产生变化，函数必须将 **UnpaidInvoice** 类型作为输出，如下所示：

```csharp
type UpdateAmountDue = UnpaidInvoice -> AmountDue -> UnpaidInvoice
```

这清楚地表明，提供一个 UnpaidInvoice 实例和一个 AmountDue 的值，就能返回另一个不同的 UnpaidInvoice。不可变性迫使我们在设计中明确业务逻辑。

### 6.1. 不可变性和聚合边界

在确定聚合边界时，不可变性可以发挥巨大的作用。假设我们有一个 Order 类型，其中包含了一个 OrderLines 列表：

```csharp
type OrderLine = {
  OrderLineId : OrderLineId
  ProductId : ProductId
  OrderQty : OrderQty
}
 
type Order = {
  OrderId : OrderId
  Lines : OrderLine list
}
```

但现在问题来了：如果其中一个 OrderLine 发生了变化，其所属的 Order 是否也要跟着变化？在这种场景下，答案很明显是肯定的：**修改订单行，就意味着要修改整个订单**。

如果使用了不可变数据，上述设计就很自然。如果 Order 不可变，其包含的 OrderLines 也不可变，那么创建其中一个 OrderLine 的副本，是不会同时创建 Order 副本的。因此，为了修改 Order 中的 OrderLine，就需要在 Order 这个层面进行修改，而不是在 OrderLine 层面进行修改。

例如，修改特定订单行价格的函数定义如下。它需要 Order、要修改的订单行的OrderLineId 以及新的 Price：

```csharp
type ChangeOrderLinePrice = Order -> OrderLineId -> Price -> Order
```

最终结果（即函数的输出）就是一个**新的 Order**，它包含了一个新的订单行列表，其中有一个订单行已经标上了新的价格。我们看到不可变性在数据结构中引起了连锁反应，一个低层级的组件发生变化会迫使更高层级的组件也发生变化

因此，即使要修改的只是一个“子实体”（OrderLine），我们也必须始终在 Order 这个层面上进行修改。换句话说，不可变性迫使我们将 Order 定义成**聚合根**，并且要求所有修改都在 Order 这个层面上进行，而不是在订单行这个层面进行，而这正中我们下怀。

### 6.2. 聚合引用

现在假设我们需要将客户信息关联到 Order 上。像下面这样，将 Customer 作为 Order的一个字段是一种糟糕的设计：

```csharp
type Order = {
  OrderId : OrderId
  Customer : Customer // 与订单相关联的客户信息
  Lines : OrderLine list
 // 其他字段
}
```

为什么说这是一个糟糕的设计？不变性的连锁效应迫使我们在修改任意**客户**信息时也要修改关联的*订单*。我们真的想要这么做吗？

不，应该不会。**持有客户的引用**而不是**客户记录**本身，显然是一种更好的设计。也就是说，Order 类型只持有 CustomerId，如下所示：

```csharp
type Order = {
  OrderId : OrderId
  CustomerId : CustomerId // 与订单关联的客户ID
  Lines : OrderLine list
 // 其他字段
}
```

当需要客户的完整信息时，可以从 Order 中得到 CustomerId，然后再从数据库加载相关的客户数据，而不是将这些数据作为订单的一部分加载。换句话说，Customer 和 Order 是**不同**而且**独立**的两个聚合。它们各自对内部一致性负责，它们之间唯一的连接就是聚合根对象的标识。

我们又一次目睹了不可变性对设计的帮助，它帮助我们探索实体到底是属于同一聚合（订单和订单行）还是分属不同聚合（订单和客户）。



## 7. 隐藏非法状态

我们好不容易才正确地进行了建模，必须未雨绸缪，确保领域中的所有数据有效且一致。我们的目标是创建一个限界上下文，将可以信任的数据放在其内部，用明确的边界将它们与不受信任的外部世界隔开。如果可以确保所有数据始终有效，那么实现代码就能保持整洁，而且不用编写防御性的代码。

因此，在最后一节里，我们会介绍一些通过隐藏非法状态来避免无效数据的技术。换句话说，**设计本身**就可以明确地表示规则和逻辑，无需依赖堆砌在代码中的合法性检查。而且，在强制类型检查的语言中，编译器根本就不允许数据无效！这意味着总体上要写的单元测试更少，要写的防御性代码更少，要写的实现代码也更少。

下面罗列了一些我们在设计中常用的手段：

- 用可选值避免 null
- 强化约束
- 强化业务规则

### 7.1. 用可选值避免 null

半个世纪以来，null 一直是程序员的阿克琉斯之踵。其提出 null 概念的 Tony Hoare 称之为“价值亿万美金的错误”。从设计的角度来看，null 会使问题变得复杂，因为这导致我们永远无法确定某个值是否是可选的。

在大多数使用**代数类型系统**的语言中，**null 是不存在的**。这意味着领域模型中任意一个引用值都是**必要**值。但有时的确需要指出数据在某些情况下可能是可选的。怎样才能在设计中体现这一点呢？

答案是思考缺失的数据究竟意味着什么。要么存在，要么不存在。要么有些什么，要么什么都没有。我们可以使用一种特殊的选择类型（在 F# 中称为 Option，在其他语言中称为 Maybe）来对它建模，其定义如下：

```csharp
type Option<'a> =
 | Some of 'a
 | None
```

Some 选项表示关联的值 'a 中存储了数据。None 选项表示没有数据。 'a 中左边的**单引号**是 F# 表示**泛型类型**的方式，也就是说 Option 类型可用于包装其他**任何**类型。C# 和Java 则可以使用 Option<T> 这样的泛型定义可选值。

要在领域模型中表示可选数据，我们需要将类型包装在 Option<...> 中，就像在 C# 和 Java 那样。例如，对于 PersonalName 类型来说，名字和姓氏是必要的，但中间名的首字母是可选的，我们可以像下面这样建模：

```csharp
type PersonalName = {
  FirstName : string            // 必要的
  MiddleInitial: Option<string> // 可选的
  LastName : string             // 必要的
}
```

这段代码非常清楚地说明了哪些字段是可选的，哪些是字段必要的。

### 7.2. 强化约束

在现实世界领域中，没有任何限制的整数或字符串非常少见。这些值几乎总是要满足某种形式的约束。在前面的例子中，我们提到了下面这些值：

> *data OrderQuantity is int // 大于等于 1 小于等于 100*
> *data EmailAddress is string // 不能为 null，也不能是空字符串，必须包含字符 @。*

这里不能使用原始的 int 值和 string 值。我们要确保下面这一点，如果确实是 OrderQuantity 和 EmailAddress，它们*一定*要满足约束。如果类型创建好之后就再也无需检查约束，那么就不需要编写更多防御性的代码。

这听起来不错，那么该如何确保约束强制生效？无论使用哪种编程语言，答案都一样：将构造函数设为私有，编写一个独立函数来构造有效的值，这个函数还会返回出错信息来拒绝无效的值。函数式编程社区有时将这种方法称为**智能构造函数**。

下面是在 OrderQuantity 上应用这种方法的例子：

```csharp
type OrderQuantity = private OrderQuantity of int
 // ^ 私有构造函数
 
// 定义一个和类型相同名称的模块
module OrderQuantity =
 
 /// 为 OrderQuantity 定义一个"智能构造器"
 let create qty =
 if qty < 1 then
 // 失败
      Error "OrderQuantity can not be negative"
 else if qty > 100 then
 // 失败
      Error "OrderQuantity can not be more than 100"
 else
 // 成功——构造 OrderQuantity 的值并返回
      Ok (OrderQuantity qty)
```

由于构造函数是私有的，所以**不能**直接构造 OrderQuantity 的值，但可以使用“工厂”函数 OrderQuantity.create 来构造。

create 函数接受一个 int 参数，并返回一个 Result 类型，即可以表示成功，也可以表示失败。函数签名可以清楚地表达出这两种可能性：

```csharp
int -> Result<OrderQuantity,string>.
```

上面的设计直白地告诉我们 OrderQuantity 的构造可能失败。但是，一旦 OrderQuantity 值成功构造，不可变性就能确保它永远不会发生变化，因此始终都是有效的。

### 7.3. 在设计中抓住业务规则

仅靠类型系统记录业务规则就足够了吗？换句话说，我们希望使用类型系统来表示有效或无效的值，这样编译器可以帮我们检查，而不用依靠运行时的检查或代码注释来确保规则的维护。

答案往往出乎意料，我们其实可以做到这一点。耳听为虚，眼见为实。我们假设有一条关于客户联系方式的业务规则：“客户必须有电子邮箱或邮政地址。”

该如何表示这一业务规则呢？首先可以创建一个记录，它拥有 Email 和 Address 两个字段，如下所示：

```csharp
type Contact = {
  Name: Name
  Email: EmailContactInfo
  Address: PostalContactInfo
}
```

但这个设计是错误的。这意味着 Email 和 Address 都是必要的。

没问题，把它们改成可选的。

```csharp
type Contact = {
  Name: Name
  Email: Option<EmailContactInfo>
  Address: Option<PostalContactInfo>
}
```

但这还是不对。因为这样一来，Email 和 Address 可能都没有值，而这破坏了业务规则。我们当然可以增加特殊的运行时检查来确保这种情况不会发生。但是有没有更好的设计，让业务规则体现在类型系统中？当然有了！

这里有个诀窍，仔细地推敲业务规则。这条规则意味着一位客户：

- 仅有一个电子邮箱地址，或者
- 仅有一个邮政地址，或者
- 同时拥有电子邮箱地址和邮政地址

只有这**三种**可能性。如何表示这三种可能性？当然是用选择类型了！

```csharp
type BothContactMethods = {
  Email: EmailContactInfo
  Address : PostalContactInfo
}
 
type ContactInfo =
 | EmailOnly of EmailContactInfo
 | AddrOnly of PostalContactInfo
 | EmailAndAddr of BothContactMethods
```

然后，就可以在最重要的 Contact 类型中使用这个选择类型了，如下所示：

```csharp
type Contact = {
  Name: Name
  ContactInfo : ContactInfo
}
```

这又一次说明，我们所做的一切能除了能给开发人员带来便利（根本就不会出现没有联系信息的意外情况，这样就能少写一个测试），也能给**设计**带来便利。上述设计非常清楚地表明了只有三种可能的情况，也说明了这三种情况的确切含义。我们都不需要查看文档，只用看看代码就能明白。

## 8. 总结

浏览一下上面这些代码片段，我们应该感到欣慰。因为我们已经抓住了使用**词汇描述领域的本质**，还是以代码的形式，而不是以文本或文档的形式。

站在开发人员的角度，我们已经实现了领域驱动设计的目标：写出了能够定义并实现领域模型以及统一语言的可编译代码。新加入项目的开发人员，无需在实现概念和领域概念之间来回切换，就能理解领域模型。

**这些代码非开发人员也很容易理解**。我相信领域专家只用经过简单培训就能够理解这些代码。理解这些代码不会比理解 UML 图或其他技术文档更困难。这些代码的可读性也肯定比 C#、Java 这些常见的编程语言更好。

这种使用类型作为文档的方法，具有普遍意义。读到这里，你应该清楚如何将其应用于几乎所有领域建模的场景。因为这时还没有涉及具体实现，所以在与领域专家合作的过程当中，这不失为一种快速验证想法的不错方式。当然，这些代码只是文本，领域专家无需借助任何特殊工具就可以轻松审阅，甚至可以自己动手写下一些类型！